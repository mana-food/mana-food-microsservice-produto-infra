name: Deploy Mana Food Product - Aurora RDS + Secrets Manager

on:
  workflow_dispatch:
    inputs:
      deploy_mode:
        description: "Modo de deploy"
        type: choice
        options:
          - "full-deploy"
          - "infra-only"
        default: "full-deploy"
  push:
    branches:
      - main

permissions:
  contents: read
  packages: write
  id-token: write

env:
  ECR_REPOSITORY_API: mana-food-product-api
  AWS_REGION: us-east-1

jobs:
  # ===================================================================
  # FASE 1: INFRAESTRUTURA CR√çTICA (VPC + Aurora - 15-20 min)
  # ===================================================================
  terraform-foundation:
    name: 'Deploy VPC + Aurora (Wave 1) - 15-20 min'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: infra/terraform/envs/prod
    outputs:
      terraform-success: ${{ steps.apply.outcome }}
      aurora-endpoint: ${{ steps.outputs.outputs.aurora-endpoint }}
      aurora-secret-arn: ${{ steps.outputs.outputs.aurora-secret-arn }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Apply - Foundation
        id: apply
        run: |
          echo "üöÄ Criando infraestrutura base: VPC + Aurora MySQL (15-20 min)..."
          terraform plan -var="bucket_state_name=${{ secrets.AWS_TF_STATE_BUCKET }}" -out=tfplan
          terraform apply -auto-approve tfplan

      - name: Get Foundation Outputs
        id: outputs
        if: steps.apply.outcome == 'success'
        run: |
          AURORA_ENDPOINT=$(terraform output -raw aurora_endpoint)
          AURORA_SECRET_ARN=$(terraform output -raw aurora_secret_arn)
          
          echo "aurora-endpoint=$AURORA_ENDPOINT" >> $GITHUB_OUTPUT
          echo "aurora-secret-arn=$AURORA_SECRET_ARN" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Aurora Endpoint: $AURORA_ENDPOINT"
          echo "üîê Aurora Secret ARN: $AURORA_SECRET_ARN"

  # ===================================================================
  # FASE 2: AGUARDAR AURORA (Cr√≠tico - 15-20 min)
  # ===================================================================
  wait-aurora:
    name: 'Aguardar Aurora Dispon√≠vel (15-20 min)'
    runs-on: ubuntu-latest
    needs: terraform-foundation
    if: needs.terraform-foundation.outputs.terraform-success == 'success'

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for Aurora availability
        run: |
          echo "‚è≥ Aguardando Aurora estar dispon√≠vel (pode demorar 15-20 min)..."
          
          # Timeout aumentado para 1200s (20 min) - Aurora Serverless v2 pode demorar
          timeout 1200 bash -c "
            ATTEMPT=0
            while true; do
              ATTEMPT=\$((ATTEMPT+1))
              STATUS=\$(aws rds describe-db-clusters --db-cluster-identifier mana-food-aurora --region ${{ env.AWS_REGION }} --query 'DBClusters[0].Status' --output text 2>/dev/null || echo 'unknown')
          
              echo \"Tentativa \$ATTEMPT - Status atual: \$STATUS\"
          
              if [ \"\$STATUS\" = \"available\" ]; then
                echo \"‚úÖ Aurora dispon√≠vel!\"
                exit 0
              fi
          
              if [ \"\$STATUS\" = \"failed\" ] || [ \"\$STATUS\" = \"deleting\" ]; then
                echo \"‚ùå Aurora em estado cr√≠tico: \$STATUS\"
                exit 1
              fi
          
              if [ \"\$STATUS\" = \"unknown\" ]; then
                # Debug extra a cada 4 tentativas quando ainda unknown
                if [ \$((ATTEMPT % 4)) -eq 0 ]; then
                  echo \"üîé Debug: listando clusters vis√≠veis...\"
                  aws rds describe-db-clusters --region ${{ env.AWS_REGION }} --query 'DBClusters[].{Id:DBClusterIdentifier,Status:Status}' || true
                fi
              fi
          
              sleep 30
            done
          "

      - name: Verify Secrets Manager
        run: |
          SECRET_ARN="${{ needs.terraform-foundation.outputs.aurora-secret-arn }}"
          echo "üîê Verificando AWS Secrets Manager..."
          echo "Secret ARN: $SECRET_ARN"
          
          # Testar acesso ao secret
          aws secretsmanager describe-secret --secret-id "$SECRET_ARN" --region ${{ env.AWS_REGION }}
          echo "‚úÖ AWS Secrets Manager configurado corretamente"

  # ===================================================================
  # FASE 3: INFRAESTRUTURA COMPUTE (EKS - 8-12 min)
  # ===================================================================
  terraform-compute:
    name: 'Deploy EKS (Wave 2) - 8-12 min'
    runs-on: ubuntu-latest
    needs: [terraform-foundation, wait-aurora]
    defaults:
      run:
        working-directory: infra/terraform/envs/prod
    outputs:
      eks-ready: ${{ steps.verify-eks.outcome }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Verify EKS Ready
        id: verify-eks
        run: |
          echo "üîç Verificando se EKS est√° pronto..."
          
          # Aguardar EKS cluster estar ativo
          aws eks wait cluster-active --name mana-food-eks --region ${{ env.AWS_REGION }}
          
          # Configurar kubectl
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name mana-food-eks
          
          # Verificar nodes prontos
          timeout 300 bash -c "
            while true; do
              READY_NODES=\$(kubectl get nodes --no-headers | grep Ready | wc -l)
              if [ \"\$READY_NODES\" -ge 2 ]; then
                echo \"‚úÖ EKS cluster pronto com \$READY_NODES nodes\"
                break
              fi
              echo \"‚è≥ Aguardando nodes EKS (\$READY_NODES/2 prontos)...\"
              sleep 30
            done
          "
          
          echo "‚úÖ EKS cluster completamente operacional"

  # ===================================================================
  # FASE 4: CONFIGURA√á√ÉO E DEPLOY (2-5 min)
  # ===================================================================

  deploy-apps:
    name: 'Deploy API .NET 9 no EKS'
    runs-on: ubuntu-latest
    needs: [terraform-foundation, terraform-compute]
    if: needs.terraform-compute.outputs.eks-ready == 'success'

    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure kubectl and verify IAM
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name mana-food-eks
          
          echo "üîç Verificando se EKS nodes podem acessar Secrets Manager..."
          SECRET_ARN="${{ needs.terraform-foundation.outputs.aurora-secret-arn }}"
          
          # Teste b√°sico de conectividade
          aws secretsmanager describe-secret --secret-id "$SECRET_ARN" --region ${{ env.AWS_REGION }}
          echo "‚úÖ Secret est√° acess√≠vel"

      - name: Deploy aplica√ß√µes .NET 9 no EKS
        run: |
          # Configura√ß√µes
          AURORA_ENDPOINT="${{ needs.terraform-foundation.outputs.aurora-endpoint }}"
          AURORA_SECRET_ARN="${{ needs.terraform-foundation.outputs.aurora-secret-arn }}"
          
          echo "üöÄ Deployando ManaFood .NET 9 no EKS com AWS Secrets Manager..."
          echo "üóÑÔ∏è Aurora RDS: $AURORA_ENDPOINT"
          echo "üîê Aurora Secret: $AURORA_SECRET_ARN"
          echo "üìã API .NET 9 aplicar√° migrations automaticamente"
          
          # Deploy seguindo arquitetura obrigat√≥ria com Secrets Manager
          kubectl apply -f - <<EOF
          # Secrets com Aurora Secret ARN
          apiVersion: v1
          kind: Secret
          metadata:
            name: mana-food-product-secrets
            namespace: default
          type: Opaque
          stringData:
            aurora-secret-arn: "$AURORA_SECRET_ARN"
          ---
          # ConfigMap
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: mana-food-product-config
            namespace: default
          data:
            ASPNETCORE_ENVIRONMENT: "Production"
            ASPNETCORE_URLS: "http://+:8080"
            DATABASE_HOST: "$AURORA_ENDPOINT"
          ---
          # API .NET 9 Deployment (aplica migrations automaticamente)
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: mana-food-product-api
            namespace: default
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: mana-food-product-api
            template:
              metadata:
                labels:
                  app: mana-food-product-api
              spec:
                containers:
                - name: api
                  image: YOUR_ECR_REGISTRY/mana-food-product-api:latest
                  ports:
                  - containerPort: 8080
                  env:
                  # ‚úÖ NOVA CONFIGURA√á√ÉO: Usar Secret ARN
                  - name: AURORA_SECRET_ARN
                    valueFrom:
                      secretKeyRef:
                        name: mana-food-product-secrets
                        key: aurora-secret-arn
                  envFrom:
                  - configMapRef:
                      name: mana-food-product-config
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                  startupProbe:
                    httpGet:
                      path: /healthz
                      port: 8080
                    initialDelaySeconds: 10
                    periodSeconds: 5
                    timeoutSeconds: 3
                    failureThreshold: 12
                  readinessProbe:
                    httpGet:
                      path: /healthz
                      port: 8080
                    initialDelaySeconds: 30
                    periodSeconds: 5
                    timeoutSeconds: 3
                    failureThreshold: 2
                  livenessProbe:
                    httpGet:
                      path: /healthz
                      port: 8080
                    initialDelaySeconds: 60
                    periodSeconds: 10
                    timeoutSeconds: 5
                    failureThreshold: 3
          ---
          # API Service (p√∫blico com LoadBalancer)
          apiVersion: v1
          kind: Service
          metadata:
            name: mana-food-product-api-service
            namespace: default
          spec:
            selector:
              app: mana-food-product-api
            ports:
            - port: 80
              targetPort: 8080
            type: LoadBalancer
          EOF

      - name: Monitor deployment progress
        run: |
          echo "üîç Verificando status dos pods..."
          kubectl get pods -l app=mana-food-product-api -o wide
          
          echo "‚è≥ Aguardando API aplicar migrations com credenciais do Secrets Manager..."
          kubectl rollout status deployment/mana-food-product-api --timeout=300s
          
          echo "üìä Status final dos pods:"
          kubectl get pods -o wide
          kubectl get svc -o wide

      - name: Verificar arquitetura deployada
        run: |
          echo "üîç Logs da API (migrations com Secrets Manager):"
          kubectl logs deployment/mana-food-product-api --tail=30 || echo "Logs ainda n√£o dispon√≠veis"
          
          echo ""
          echo "üåê Aguardando Load Balancer da API..."
          
          timeout 300 bash -c '
            while true; do
              LB_HOSTNAME=$(kubectl get svc mana-food-product-api-service -o jsonpath="{.status.loadBalancer.ingress[0].hostname}" 2>/dev/null)
              if [ -n "$LB_HOSTNAME" ] && [ "$LB_HOSTNAME" != "null" ]; then
                echo "üîó ManaFood API: http://$LB_HOSTNAME"
                echo ""
                echo "‚úÖ ARQUITETURA MANA FOOD DEPLOYADA COM AWS SECRETS MANAGER!"
                echo "üèóÔ∏è Fluxo: Internet ‚Üí API .NET 9 ‚Üí Aurora RDS"
                echo "üîê API .NET 9 obt√©m credenciais via AWS Secrets Manager"
                echo "üìã Aplica√ß√£o .NET 9 aplicou migrations automaticamente"
                echo "‚ö° API .NET 9 conectada ao Aurora RDS"
                break
              fi
              echo "‚è∞ Aguardando Load Balancer..."
              sleep 30
            done
          ' || echo "‚ö†Ô∏è Timeout aguardando Load Balancer"

  # ===================================================================
  # ROLLBACK E STATUS
  # ===================================================================
  rollback:
    name: 'Rollback'
    runs-on: ubuntu-latest
    needs: [terraform-foundation, terraform-compute, deploy-apps]
    if: failure() && (needs.terraform-foundation.result == 'success')
    defaults:
      run:
        working-directory: infra/terraform/envs/prod

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.AWS_TF_STATE_BUCKET }}" \
            -backend-config="key=mana-food-prod.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Cleanup EKS Apps
        run: |
          echo "üßπ Limpando aplica√ß√µes do EKS..."
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name mana-food-eks || true
          kubectl delete deployment mana-food-product-api || true
          kubectl delete service mana-food-product-api-service || true
          kubectl delete configmap mana-food-product-config || true
          kubectl delete secret mana-food-product-secrets || true
        continue-on-error: true

      - name: Terraform Destroy
        run: |
          echo "üö® Executando rollback da infraestrutura..."
          terraform destroy -var="bucket_state_name=${{ secrets.AWS_TF_STATE_BUCKET }}" -auto-approve
        continue-on-error: true

      - name: Cleanup ECR Images
        run: |
          echo "üóëÔ∏è Limpando imagens ECR..."
          aws ecr delete-repository --repository-name mana-food-product-api --force --region ${{ env.AWS_REGION }} || true
        continue-on-error: true

  status:
    name: 'Status Final'
    runs-on: ubuntu-latest
    needs: [terraform-foundation, wait-aurora, terraform-compute, deploy-apps, rollback]
    if: always()

    steps:
      - name: Generate report
        run: |
          echo "üéØ MANA FOOD - INFRAESTRUTURA COM VPC + AURORA + EKS"
          echo "=============================================================="
          echo "Foundation (VPC+Aurora): ${{ needs.terraform-foundation.result }}"
          echo "Aurora Wait: ${{ needs.wait-aurora.result }}"
          echo "Compute (EKS): ${{ needs.terraform-compute.result }}"
          echo "Apps Deploy: ${{ needs.deploy-apps.result }}"
          echo "Rollback: ${{ needs.rollback.result }}"
          echo ""
          
          if [ "${{ needs.rollback.result }}" = "success" ]; then
            echo "üö® ROLLBACK EXECUTADO COM SUCESSO"
            echo "  ‚Ä¢ Aplica√ß√µes EKS removidas"
            echo "  ‚Ä¢ Infraestrutura AWS destru√≠da"
            echo "  ‚Ä¢ Imagens ECR limpas"
          elif [ "${{ needs.deploy-apps.result }}" = "success" ]; then
            echo "‚úÖ MANA FOOD DEPLOYADO COM SUCESSO!"
            echo ""
            echo "üèóÔ∏è ARQUITETURA IMPLEMENTADA:"
            echo "  üóÑÔ∏è Aurora MySQL RDS - Banco central √∫nico"
            echo "  üì± API .NET 9 - Business + Migrations autom√°ticas (EKS)"
            echo "  üîê AWS Secrets Manager - Credenciais seguras"
            echo ""
            echo "üîÑ FLUXO:"
            echo "  Cliente ‚Üí API .NET 9 ‚Üí Aurora RDS"
            echo ""
            echo "‚úÖ COMPONENTES:"
            echo "  ‚Ä¢ VPC com subnets p√∫blicas e privadas"
            echo "  ‚Ä¢ Aurora RDS como fonte √∫nica de dados"
            echo "  ‚Ä¢ EKS cluster com aplica√ß√£o .NET 9"
            echo "  ‚Ä¢ AWS Secrets Manager para credenciais"
            echo "  ‚Ä¢ Aplica√ß√£o aplica migrations na inicializa√ß√£o"
            echo "  ‚Ä¢ API exposta via LoadBalancer p√∫blico"
            echo "  ‚Ä¢ N√ÉO usou connection strings hardcoded"
            echo ""
            echo "‚è±Ô∏è TIMELINE:"
            echo "  Phase 1: Foundation Deploy (VPC + Aurora)"
            echo "  Phase 2: Aurora Wait (15-20 min)"
            echo "  Phase 3: EKS Deploy (8-12 min)"
            echo "  Phase 4: App Deploy (2-3 min)"
          else
            echo "‚ùå Falha no deployment"
          fi